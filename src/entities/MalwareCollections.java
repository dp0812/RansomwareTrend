package entities;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.function.Function;

import fileReader.Logger;
import fileReader.ReadMalwareInfo;
import fileReader.WritableObject;
import utilities.Parser;
/**
 * This class provide an interface for interacting with Malware objects, and corresponding output to file instructions. 
 */
public class MalwareCollections {
    ReadMalwareInfo malwareDataset = new ReadMalwareInfo();
    ArrayList<Malware> malwareArrayList = new ArrayList<>();
    ArrayList<WritableObject> writableMalwareArrayList = new ArrayList<>();
    String inputFile;
    String outputFile;

    /**
     * This method must be called before the usage of any method inside this class. 
     * @param dataFileName Name of the dataset. Default location is in datasets directory. 
     * @param writeFileName Name of the file to be written to. Default location is outputs directory. 
     */
    public final void setUpMalware(String dataFileName, String writeFileName){
        inputFile = dataFileName;
        outputFile = writeFileName; 
        malwareDataset.readCsvFile(dataFileName);
        malwareArrayList = malwareDataset.getMalwareArrayList();
        writableMalwareArrayList = malwareDataset.getWritableArrayList();
    }
    /**
     * Sort based on date, update both malwareArrayList and writable version of it.
     */
    public final void lastestSort(){
        Comparator<Malware> firstSeen = new Comparator<Malware>() {
            public int compare(Malware o1, Malware o2) {
                if (o1.getDateTime() == null || o2.getDateTime() == null)
                    return 0;
                return o1.getDateTime().compareTo(o2.getDateTime());
            }
        };
        Collections.sort(malwareArrayList, firstSeen.reversed());
        updateWritable();
    }

    /**
     * Write to file the frequency of mime type in the dataset. 
     * @param filePath File to write. Default will be in outputs folder, under the name: mimeTypeReport.cvs
     * @return String array representation of mime type frequency in the dataset. 
     */
    public final String[] mimeTypeOccurenceReport(String filePath){
        //implicitly invoke the getMimeType method on the Malware object -> this is an instance of Function.
        if (filePath.length() == 0) filePath = "mimeTypeReport.csv";
        String[] malwareOccurenceArray = malwareOccurenceReport(Malware::getMimeType);
        Logger.writeStringArrayToFile(malwareOccurenceArray, filePath);
        return malwareOccurenceArray;
    }

    /**
     * Write to file the frequency of the signature type in the dataset. 
     * @param filePath File to write. Default will be in outputs folder, under the name: signatureReport.csv
     * @return String array representation of signature type frequency in the dataset.
     */
    public final String[] signatureOccurenceReport(String filePath){
        if (filePath.length() == 0) filePath = "signatureReport.csv";
        String[] signatureOccurenceReport = malwareOccurenceReport(Malware::getSignature);
        Logger.writeStringArrayToFile(signatureOccurenceReport, filePath);
        return signatureOccurenceReport;
    }

    /**
     * Write to file the frequency of the file type in the dataset. 
     * @param filePath File to write. Default will be in outputs folder, under the name: fileTypeReport.csv
     * @return String array representation of file type frequency in the dataset.
     */
    public final String[] fileTypeOccurenceReport(String filePath){
        if (filePath.length() == 0) filePath = "fileTypeReport.csv";
        String[] fileTypeOccurenceReport = malwareOccurenceReport(Malware::getFileType);
        Logger.writeStringArrayToFile(fileTypeOccurenceReport, filePath);
        return fileTypeOccurenceReport;
    }

    /**
     * Created for optimal code re-use when invoking the multiple getter methods of Malware objects which return a String value x. 
     * This method provide the facility to verify how many objects has the same value x.
     * @param slicer This slicer must order the Object to invoke a method which return value is a String. 
     * @return A String array representation of the occurence report which the category is the first line, and the value is the second line. 
     */
    private final String[] malwareOccurenceReport(Function <Malware, String> slicer){
        LinkedHashMap<String, Integer> reportMap = new LinkedHashMap<>();
        for (Malware m: malwareArrayList){
            String key = slicer.apply(m).trim(); //The lambda is now: String apply (Malware m);
            reportMap.merge(key, 1,Integer::sum); //if found key, add 1 to the value at key. else create key, then initialize it with 1. 
        }
        return Parser.flattenStructure(Parser.sortByValue(reportMap), ',');
    }

    /**
     * Clear the outdated version of writableMalwareArrayList, then populate it with the content from malwareArrayList. 
     */
    private final void updateWritable(){
        writableMalwareArrayList.clear();
        for (Malware m : malwareArrayList){
            WritableObject w = m;
            writableMalwareArrayList.add(w);
        }
    }

    /**
     * Write to file the information about Malware objects that we would like to visualize, then provide an approximation of the time it took to write. 
     * This result is system dependent, and heavily affect by the warm up process (i.e. if another file writer is invoked before this, it will runs faster by 5 to 6 ms).
     * @return An approximation of the time to write this file, using System.currentTimeMillis(); 
     */
    public final long writeVisualizationData(){
        long startTime = System.currentTimeMillis();
        Logger.writeVisualizationData(writableMalwareArrayList, malwareDataset.getCategoryLine(),outputFile);
        long endTime = System.currentTimeMillis();
        return endTime - startTime;
    }
    
    /**
     * Provide an ArrayList of Malware objects. 
     * @return a clean ArrayList, in the order that it is read from file.  
     */
    public ArrayList<Malware> getMalwareArrayList(){
        return this.malwareArrayList;
    }

}
