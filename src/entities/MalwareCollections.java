package entities;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.function.Function;

import fileReader.Logger;
import fileReader.ReadMalwareInfo;
import fileReader.WritableObject;
import utilities.Parser;

public class MalwareCollections {
    ReadMalwareInfo malwareDataset = new ReadMalwareInfo();
    ArrayList<Malware> malwareArrayList = new ArrayList<>();
    ArrayList<WritableObject> writableMalwareArrayList = new ArrayList<>();
    String inputFile;
    String outputFile;

    /**
     * @param dataFileName Name of the dataset. Default location is in datasets directory. 
     * @param writeFileName Name of the file to be written to. Default location is outputs directory. 
     */
    public final void setUpMalware(String dataFileName, String writeFileName){
        inputFile = dataFileName;
        outputFile = writeFileName; 
        malwareDataset.readCsvFile(dataFileName);
        malwareArrayList = malwareDataset.getMalwareArrayList();
        writableMalwareArrayList = malwareDataset.getWritableArrayList();
    }
    /**
     * Sort based on date, update both malwareArrayList and writable version of it.
     */
    public final void lastestSort(){
        Comparator<Malware> firstSeen = new Comparator<Malware>() {
            public int compare(Malware o1, Malware o2) {
                if (o1.getDateTime() == null || o2.getDateTime() == null)
                    return 0;
                return o1.getDateTime().compareTo(o2.getDateTime());
            }
        };
        Collections.sort(malwareArrayList, firstSeen.reversed());

        updateWritable();

    }

    public final String[] mimeTypeOccurenceReport(){
        //implicitly invoke the getMimeType method on the Malware object -> this is an instance of Function.
        return malwareOccurenceReport(Malware::getMimeType);
    }
    public final String[] signatureOccurenceReport(){
        return malwareOccurenceReport(Malware::getSignature);
    }
    public final String[] fileTypeOccurenceReport(){
        return malwareOccurenceReport(Malware::getFileType);
    }
    /**
     * Created for optimal code re use when invoking the multiple getter methods of Malware objects which return a String value x. 
     * This method provide the facility to verify how many objects has the same value x.
     * @param slicer This slicer must order the Object to invoke a method which return value is a String. 
     * @return A String array representation of the occurence report which the category is the first line, and the value is the second line. 
     */
    private final String[] malwareOccurenceReport(Function <Malware, String> slicer){
        LinkedHashMap<String, Integer> reportMap = new LinkedHashMap<>();
        for (Malware m: malwareArrayList){
            String key = slicer.apply(m); //The lambda is now: String apply (Malware m);
            if (!reportMap.containsKey(key)) reportMap.put(key, 0);
            reportMap.replace(key, reportMap.get(key)+1);
        }
        return Parser.flattenStructure(reportMap, ',');
    }

    private final void updateWritable(){
        writableMalwareArrayList.clear();
        for (Malware m : malwareArrayList){
            WritableObject w = m;
            writableMalwareArrayList.add(w);
        }
    }

    public final void writeVisualizationData(){
        Logger.writeVisualizationData(writableMalwareArrayList, malwareDataset.getCategoryLine(),outputFile);
    }

    public ArrayList<Malware> getMalwareArrayList(){
        return this.malwareArrayList;
    }


}
