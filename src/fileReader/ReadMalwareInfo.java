package fileReader;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedHashMap;

import entities.Malware;
import utilities.Parser;

/**
 * Reads data from csv, created malware objects, create 3 ArrayList representation: 
 * one contains the malware objects, 
 * one contains String array form of the dataset,
 * one contains the writable objects (use in writing to file).
 */
public class ReadMalwareInfo implements CsvReader {
    /** stores any file lines that are read */
    private ArrayList <String[]> fileContent = new ArrayList<>();
    /** stores malware objects taken from the file read */
    private ArrayList <Malware> malwareArrayList = new ArrayList<>();
    /** stores writable version of malware objects taken from the file read */
    private ArrayList <WritableObject> writableMalwareArrayList = new ArrayList<>();
    /** for creating the objects no matter how much the order of the columns in the csv has changed */
    private LinkedHashMap <String, Integer> categoryTable = new LinkedHashMap<>();
    
    /**
     * Accepts a file name, read from said csv file using BufferedReader and add the content to ArrayList of String array. 
     * This method ignore a certain set of lines hardcoded. 
     * @param fileName this is a name with the extension, do not provide any path. 
     */
    public final void readCsvFile(String fileName){
        delayTillTransientLockIsCleared(500);
        //ensure consistency by constructing the file path again.
        Path targetDir = Paths.get(CsvSaver.TARGET_DIRECTORY); 
        Path targetFilePath = targetDir.resolve(fileName);
        //use the filepath constructed as the param for creating InputStream. 
        try(InputStream inputStream = Files.newInputStream(targetFilePath);
            BufferedReader input = new BufferedReader( new InputStreamReader(inputStream))){
            String line ="";
            for (int i = 0; i < 8; i++) line = input.readLine(); //skip 8 lines of credit - temporary fix. 
            String categoryLine = input.readLine();
            String[] categoryArr = Parser.simpleParser(categoryLine, ',');
            setCategoryTableContentForReadFile(categoryArr);
        
            while (((line = input.readLine())!= null)  && ((line.charAt(0))!='#')){
                String[] arr = Parser.simpleParser(line, ',');
                fileContent.add(arr);
            }

        }catch (NullPointerException errNull) {
            IO.println("Unintialized resouce for InputStream: " + errNull);
        }catch (IOException errIO){
            IO.println("Failed to open file: " + errIO);
        } finally{
            processList();
        }
    }
    
    /** Simple per line information from file. In this class specifically: the content is enclosed in quote marks. */
    public final ArrayList<String[]> getFileContent(){
        return this.fileContent; 
    }

    /** 
     * Gets the processed list of malware objects.
     * @return the ArrayList of malware objects
     */
    public final ArrayList<Malware> getMalwareArrayList(){
        return this.malwareArrayList;
    }

    /** Gets the writable list of writable malware objects. */
    public final ArrayList<WritableObject> getWritableArrayList(){
        return this.writableMalwareArrayList;
    }

    /** Gets the Malware category line. */
    public final String[] getCategoryLine(){
        return Malware.getVisualizationInfoArray(malwareArrayList.get(0));
    }

    /** 
     * Processes the file content list to create malware objects for each line and update 2 arrayList: 
     * malwareArrayList and writableMalwareArrayList
     */
    private void processList(){
        //remove outdated info. 
        malwareArrayList.clear();
        writableMalwareArrayList.clear();
        //process newly obtained info. 
        for (String[] someLine : fileContent){
            Malware malwareObject = createMalwareObject(someLine);
            WritableObject writableMalwareObject = createMalwareObject(someLine);
            malwareArrayList.add(malwareObject);
            writableMalwareArrayList.add(writableMalwareObject);
        }
    }

    /**
     * Initialize the attribute categoryTable: key: category name, value: index of data.  
     * Index of data is the index of required data in the rows excluding the category row in the csv.
     * categoryTable.get(key) with key as a string (a category) will return the correct index in the csv
     * @param arr string array representation of the category name in the csv
     */
    private void setCategoryTableContentForReadFile(String[] arr){
        int index  = 0;
        for (String category: arr){ //strip the # from the category line of the csv, then strip all quotes. 
            String stripCat = category.replaceAll("#","").replaceAll("\"","" ).trim();
            this.categoryTable.put(stripCat, index++);
        }
    }
    /** 
     * Creates the Malware objects with the given info from the file.
     * @param someLine the file line stored as a string array
     */
    private Malware createMalwareObject(String[] someLine){
        Malware malwareObject = new Malware(
            someLine[categoryTable.get("first_seen_utc").intValue()],
            someLine[categoryTable.get("sha256_hash").intValue()],
            someLine[categoryTable.get("reporter").intValue()],
            someLine[categoryTable.get("file_name").intValue()],
            someLine[categoryTable.get("file_type_guess").intValue()],
            someLine[categoryTable.get("mime_type").intValue()],
            someLine[categoryTable.get("signature").intValue()]
        );
        return malwareObject;
    }

    /**
     * This method impose a wait on the thread to ensure the transient lock on a newly fetched file is clear. 
     * If this wait time is not present (or not long enough - this is system dependent), the file is still locked after fetch, and the 1st execution would failed but the 2nd one would works.
     * @param waitTime wait time, in miliseconds. Default waitime is 200 ms, any value less than 200 ms is auto adjusted to 200 ms
     */
    private void delayTillTransientLockIsCleared(long waitTime){
        if (waitTime < 200) waitTime = 200;
        try {
            IO.println("Waiting " + waitTime +  " milliseconds for file system lock to clear...");
            Thread.sleep(waitTime); 
        } catch (InterruptedException e){
            IO.println("Delay failed.");
            Thread.currentThread().interrupt();
        }
    }
}
